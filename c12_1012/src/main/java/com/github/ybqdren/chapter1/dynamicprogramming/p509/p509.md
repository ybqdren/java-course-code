# 题解一 ： Leetcode 官方 (com.github.ybqdren.chapter1.dynamicprogramming.other.solved1)

## 方法一：动态规划
由于斐波那契数存在地递推关系，因此可以使用动态规划进行求解：

- 斐波那契数列的边界条件：  F(0) = 0  和 F(1) = 1，当 n > 1，每一项的和都等于前两项的和

- 递推关系（由上面得出）： F(n) = F(n - 1) + F(n -2)

- 状态转移方程（动态规划）：上面的递推关系

- 边界条件： F(0) 和 F(1)

根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n) 的实现。


由于 F(n) 只和 F(n-1) 与 F(n-2) 有关，因此可以使用 `滚动数组思想`，
把空间复杂度优化成 O(1)：
![](https://assets.leetcode-cn.com/solution-static/509/509_fig1.gif)


代码如下：

```java
public static int fib_1(int n) {
    if(n < 2){return n;}
    int p = 0,q = 0,r = 1;
    for(int i = 2 ; i<= n ; ++i){
        p = q;
        q = r;
        r = p + q;
    }
    return r;
}
```

时间复杂度为 `O(n)`，空间复杂度为 `O(1)`。


## 方法二：矩阵快速幂




```java
public static int fib_2(int n) {
    if(n < 2){return n;}

    int[][] q = {{1,1},{1,0}};
    int[][] res = pow(q,n - 1);
    return res[0][0];
}

public static int[][] pow(int[][] arr,int n){
    int[][] ret = {{1,0},{0,1}};
    while (n > 0){
        if((n & 1) == 1){
            ret = multiply(ret,arr);
        }
        n >>= 1;
        arr = multiply(arr,arr);
    }
    return ret;
}

public static int[][] multiply(int[][] arr,int[][] brr){
    int[][] c = new int[2][2];
    for(int i=0;i < 2;i++){
        for(int j=0;j < 2;j++){
            c[i][j] = arr[i][0] * brr[0][j] + arr[i][1] * brr[1][j];
        }
    }

    return c;
}
```








## 方法三： 通项公式










> https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/