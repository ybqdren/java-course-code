package com.github.ybqdren.chapter1.dynamicprogramming;

/**
 * @author Wen(Joan) Zhao
 * @time 2022/1/8 14:05
 * @package com.github.ybqdren.chapter1.dynamicprogramming
 * @description  509. 斐波那契数  https://leetcode-cn.com/problems/fibonacci-number/
 **/
public class p509 {
    public static void main(String[] args) {
//        p509 instance = new p509();
//        instance.fib_1(2);
          fib_1(2);
          fib_2(2);
    }


    // 方法二：带备忘录的递归解法
    /**
        使用备忘录解决暴力递归产生的重复子问题后，递归树变成了递归图：
            f(20) -> f(19) -> f(18) -> f(17) -> ... -> f(2) -> f(1)

            -备忘录：
                > 每次计算某个子问题的答案后别急着返回，先将其记到 “备忘录” 里
                    再返回，每次遇到一个子问题先去 “备忘录” 里查找，如果没找到再进行递归
                    找到了，直接用
                > 一般用数组来充当 “备忘录”，也可以使用哈希表（字典），思路都是一样的


        递归算法的时间复杂度 = 子问题个数 * 解决一个子问题需要解决的问题

            - 子问题个数：
                > 即图中节点的总数，由于本算法不允许冗余计算，
                  子问题就是 f(1) 、f(2) 、f(3) ... f(20)，数量和输入规模 N=20 成正比，所以子问题的个数为 O(N)
            - 解决一个子问题的时间：
                > 没有循环，只有 f(n-1) + f(n-2) 加法操作，时间复杂度为 O(1)

            所以本算法的时间复杂度是 O(N) ，比起下面的暴力递归，已经是优化很多了

        至此，带 “备忘录” 的递归解法的效率已经和迭代的动态规划解法是一样的了。
        实际上，这种解法和迭代的动态规划已经差不多了，只不过这种解法是一种 “自顶向下” 的，
        动态规划是 “自底向上” 的。
            - 自顶向下
                > 从规模较大的原问题，向下逐渐分解规模，直到分解到了 base case，然后
                    逐层返回答案。
            - 自底向上
                > 从最下面、最简单、问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到
                    我们想要的答案 f(20)，这就是动态规划的思路，也是为什么动态规划
                    一般都脱离了递归，而是由循环迭代完成计算的关键所在。
     */
    public static int fib_2(int n) {
        if(n == 0){ return 0; }
        // 使用数组作为 “备忘录” ，存储遇到的子问题
        int memo[] = new int[n + 1];
        return helper(memo,n);
    }

    static int helper(int[] arr , int n){
        // base case
        if(n == 1 || n == 2){ return 1; }
        // 在备忘录中查找子问题，如果找到就直接返回
        if(arr[n] != 0){ return arr[n]; }
        // 没有找到子问题，继续递归查找
        arr[n] = helper(arr,n - 1) + helper(arr,n - 2);
        return arr[n];
    }





    // 方法一：暴力递归

    /**
        递归树：
                         f(20)
              f(19)                f(18)
         f(18)    f(17)        f(17)    f(16)
        .......    .....          ..........
      f(1)  f(2)  f(1) f(2)

     从上面可以看出，想要计算原问题 f(20) ，就应该先计算出子问题 f(19) 和 f(18)
     要计算 f(19)，就要先计算出子问题 f(18) 和 f(17) , 以此类推
     最后当遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树也不再向下生长了。

     观察上面这个递归树，可以很明显地发现算法低效的原因：存在大量重复计算，比如 f(18)
     被计算了两次，而且以 f(18) 为根的这个递归树体量巨大，多算一遍会耗费大量的时间
     更何况还不止 f(18) 这一个节点会被重复计算，所以这个算法非常的低效。
     < 这就是动态规划问题的第一个性质：重叠子问题。 >


     -递归算法的复杂度计算？
        复杂度 = 子问题个数 * 解决一个子问题需要的时间

        >  子问题个数：
            即递归树中节点的总数。显然二叉树节点总数为指数级别的，所以求子问题个数的时间复杂度为 O(2^n)。

        > 解决一个子问题的时间：
            在本算法中，没有循环，只有 f(n-1) + f(n-2) 加法操作，所以时间复杂度为 O（1）

        所以此递归算法的复杂度为： O(2^n)，指数级别
     */
    public static  int fib_1(int n) {
        if(n == 0){ return 0; }
        if(n == 1 || n == 2){ return 1; }
        return fib_1(n - 1) + fib_1(n - 2);
    }

}
